from celosia.hdl import get_lang_map
from amaranth.build.plat import TemplatedPlatform, tool_env_var, __version__, Iterable
from amaranth.build.run import BuildPlan
import textwrap
import re
import os
import jinja2

class Platform(TemplatedPlatform):
    def build(self, elaboratable, name="top",
              build_dir="build", do_build=True,
              program_opts=None, do_program=False,
              lang='verilog', **kwargs):

        if program_opts is None:
            program_opts = {}
        program_opts['lang'] = lang

        return super().build(
            elaboratable,
            name=name,
            build_dir=build_dir,
            do_build=do_build,
            program_opts=program_opts,
            do_program=do_program,
            **kwargs
        )

    @staticmethod
    def from_amaranth_platform(platform: TemplatedPlatform):
        if platform is not None:
            platform.toolchain_prepare = Platform.toolchain_prepare.__get__(platform)
        return platform

    def toolchain_prepare(self, fragment, name, *, emit_src=True, **kwargs):
        # Restrict the name of the design to a strict alphanumeric character set. Platforms will
        # interpolate the name of the design in many different contexts: filesystem paths, Python
        # scripts, Tcl scripts, ad-hoc constraint files, and so on. It is not practical to add
        # escaping code that handles every one of their edge cases, so make sure we never hit them
        # in the first place.
        invalid_char = re.match(r"[^A-Za-z0-9_]", name)
        if invalid_char:
            raise ValueError("Design name {!r} contains invalid character {!r}; only alphanumeric "
                             "characters are valid in design names"
                             .format(name, invalid_char.group(0)))

        # This notice serves a dual purpose: to explain that the file is autogenerated,
        # and to incorporate the Amaranth version into generated code.
        autogenerated = f"Automatically generated by Amaranth {__version__}. Do not edit."

        # Celosia
        ###########################################################################################
        lang = kwargs.get('lang', 'verilog')
        if not isinstance(lang, str):
            raise ValueError(f"Invalid 'lang': {lang}")

        ConverterClass = get_lang_map().get(lang.lower(), None)
        if ConverterClass is None:
            raise ValueError(f"Unknown 'lang': {lang}")

        converter = ConverterClass()
        hdl_text = converter.convert(fragment, name=name, fragment_prepare=False)
        self._name_map = converter.name_map
        ###########################################################################################

        # Retrieve an override specified in either the environment or as a kwarg.
        # expected_type parameter is used to assert the type of kwargs, passing `None` will disable
        # type checking.
        def _extract_override(var, *, expected_type):
            var_env = f"AMARANTH_{var}"
            if var_env in os.environ:
                # On Windows, there is no way to define an "empty but set" variable; it is tempting
                # to use a quoted empty string, but it doesn't do what one would expect. Recognize
                # this as a useful pattern anyway, and treat `set VAR=""` on Windows the same way
                # `export VAR=` is treated on Linux.
                if var_env in os.environ:
                    var_env_value = os.environ[var_env]
                return re.sub(r'^\"\"$', "", var_env_value)
            elif var in kwargs:
                kwarg = kwargs[var]
                if issubclass(expected_type, str) and not isinstance(kwarg, str) and isinstance(kwarg, Iterable):
                    kwarg = " ".join(kwarg)
                if not isinstance(kwarg, expected_type) and not expected_type is None:
                    raise TypeError(f"Override '{var}' must be a {expected_type.__name__}, not {kwarg!r}")
                return kwarg
            else:
                return jinja2.Undefined(name=var)

        def get_override(var):
            value = _extract_override(var, expected_type=str)
            return value

        def get_override_flag(var):
            value = _extract_override(var, expected_type=bool)
            if isinstance(value, str):
                value = value.lower()
                if value in ("0", "no", "n", "false", ""):
                    return False
                if value in ("1", "yes", "y", "true"):
                    return True
                else:
                    raise ValueError("Override '{}' must be one of "
                                     "(\"0\", \"n\", \"no\", \"false\", \"\") "
                                     "or "
                                     "(\"1\", \"y\", \"yes\", \"true\"), not {!r}"
                                     .format(var, value))
            return value

        def emit_rtlil():
            # TODO: Check
            # Celosia
            ###########
            return ""
            ###########

        def emit_verilog(opts=()):
            # Celosia
            ################
            return hdl_text
            ################

        def emit_debug_verilog(opts=()):
            # TODO: Check
            # Celosia
            ################
            return hdl_text
            ################

        def emit_commands(syntax):
            commands = []

            for name in self.required_tools:
                env_var = tool_env_var(name)
                if syntax == "sh":
                    template = ": ${{{env_var}:={name}}}"
                elif syntax == "bat":
                    template = \
                        "if [%{env_var}%] equ [\"\"] set {env_var}=\n" \
                        "if [%{env_var}%] equ [] set {env_var}={name}"
                else:
                    assert False
                commands.append(template.format(env_var=env_var, name=name))

            for index, command_tpl in enumerate(self.command_templates):
                command = render(command_tpl, origin=f"<command#{index + 1}>",
                                 syntax=syntax)
                command = re.sub(r"\s+", " ", command)
                if syntax == "sh":
                    commands.append(command)
                elif syntax == "bat":
                    commands.append(command + " || exit /b")
                else:
                    assert False

            return "\n".join(commands)

        @jinja2.pass_context
        def invoke_tool(context, name):
            env_var = tool_env_var(name)
            if context.parent["syntax"] == "sh":
                return f"\"${env_var}\""
            elif context.parent["syntax"] == "bat":
                return f"%{env_var}%"
            else:
                assert False

        def options(opts):
            if isinstance(opts, str):
                return opts
            else:
                return " ".join(opts)

        def hierarchy(signal, separator):
            return separator.join(self._name_map[signal][1:])

        def ascii_escape(string):
            def escape_one(match):
                if match.group(1) is None:
                    return match.group(2)
                else:
                    return f"_{ord(match.group(1)[0]):02x}_"
            return "".join(escape_one(m) for m in re.finditer(r"([^A-Za-z0-9_])|(.)", string))

        def tcl_escape(string):
            return "{" + re.sub(r"([{}\\])", r"\\\1", string) + "}"

        def tcl_quote(string):
            return '"' + re.sub(r"([$[\\])", r"\\\1", string) + '"'

        def verbose(arg):
            if get_override_flag("verbose"):
                return arg
            else:
                return jinja2.Undefined(name="quiet")

        def quiet(arg):
            if get_override_flag("verbose"):
                return jinja2.Undefined(name="quiet")
            else:
                return arg

        def render(source, origin, syntax=None):
            try:
                source   = textwrap.dedent(source).strip()
                compiled = jinja2.Template(source,
                    trim_blocks=True, lstrip_blocks=True, undefined=jinja2.StrictUndefined)
                compiled.environment.filters["options"] = options
                compiled.environment.filters["hierarchy"] = hierarchy
                compiled.environment.filters["ascii_escape"] = ascii_escape
                compiled.environment.filters["tcl_escape"] = tcl_escape
                compiled.environment.filters["tcl_quote"] = tcl_quote
            except jinja2.TemplateSyntaxError as e:
                e.args = (f"{e.message} (at {origin}:{e.lineno})",)
                raise
            return compiled.render({
                "name": name,
                "platform": self,
                "emit_rtlil": emit_rtlil,
                "emit_verilog": emit_verilog,
                "emit_debug_verilog": emit_debug_verilog,
                "emit_commands": emit_commands,
                "syntax": syntax,
                "invoke_tool": invoke_tool,
                "get_override": get_override,
                "get_override_flag": get_override_flag,
                "verbose": verbose,
                "quiet": quiet,
                "autogenerated": autogenerated,

                # Celosia
                ###############################
                "open_comment": converter.open_comment,
                "close_comment": converter.close_comment,
                ###############################
            })

        # TODO: Improve?
        # Celosia
        #####################################################################################################
        templates = self.file_templates.copy()
        def hdl_name(ext):
            return '{{name}}' + f'.{ext}'

        def hdl_debug_name(ext):
            return hdl_name(f'debug.{ext}')

        templates.pop(hdl_name('v'), None)
        templates.pop(hdl_debug_name('v'), None)
        templates[hdl_name(converter.extension)] = templates[hdl_debug_name(converter.extension)] = r"""
        {{open_comment}}{{autogenerated}}{{close_comment}}
        {{emit_verilog()}}
        """

        for key, value in templates.items():
            templates[key] = value \
                                .replace(hdl_name('v'), hdl_name(converter.extension)) \
                                .replace(hdl_debug_name('v'), hdl_debug_name(converter.extension))
        #####################################################################################################

        plan = BuildPlan(script=f"build_{name}")
        for filename_tpl, content_tpl in templates.items():
            plan.add_file(render(filename_tpl, origin=filename_tpl),
                          render(content_tpl, origin=content_tpl))
        for filename, content in self.extra_files.items():
            plan.add_file(filename, content)

        return plan